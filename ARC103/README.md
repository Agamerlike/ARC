# ARC103
Atcoder Regular Contest103の自分の解答

もたもたした結果死亡。

# C
誤読を3回ほどした結果想定よりも大幅にロス。まだ物理で殴れただけまし。

奇数番目と偶数番目の数字について、それぞれ出現回数をカウントしていき、最も多かったものを求める数列として採用すれば良い。答えはn-(oddの中で最も出現回数が多かったものではない数字の数)-(evenの中で最も出現回数が多かったものではない数字の数)となる。

ただし、odd==evenとなる場合この方法ではうまく求める数列を構成できないのでどちらかを2番目に多かったものに変更した2つの数列のうち書き換える要素の数が少なかったほうを答えとする。数字と出現回数を両方記録する必要があるためpairなどのデータ構造の使用は必須となる。

# D
久々にめちゃくちゃ頑張ったが、この実力で頑張ったところで報われるはずがなかった。

#### 部分点解
x_iとy_iの制約がかなり歪なので、アームの長さが1でも構成できる場合は間に合う。そこでアームの長さは1で決め打ち、構成できない場合について考える。余ったアームは、目標座標の近くを往復させることによって消費できる。なおこの消費1回に使うアームの数は2本であり、したがって目標座標周辺での消費は偶数回しかできない。これは任意の座標について成り立つので、したがってx_i,y_iの絶対値の和の偶奇が一致していれば構成できるだろう、ということが分かる。

abs(x_i)+abs(y_i)が奇数の場合は19本、偶数の場合は20本とし（もちろん長さはすべて1）、必要座標まで伸ばしたあとで余った分を上下もしくは左右に往復させることでうまく答えを出力できる。

#### 満点解
上の考察と微妙すぎる制約から、「bitでうまく構成できるのでは？」という発想が思い浮かぶ。実際2^20 > 10^9なのでこれは可能である。したがって1,2,4,...,2^19のアームを2セット作り、これでやりくりして構成していくという方針が思い浮かんだ。

しかし、これには無駄が多すぎる。適切に無駄を削ることで、先ほどのアームの長さでは表現できないx_iとy_iのどちらか一方でのみbitが立っているケースを処理できそうである。これは他の座標に干渉しないための条件を考慮すると、長さ2^(bit-1)のアームを2本用意するのがよいだろう、ということが分かる。これを用いて、すべての座標に行くために必要なアーム数を求める手順を以下のようにする。

1. それぞれの座標についてabs(x)とabs(y)でandを取り、必ず2本のアームが必要になるbitを割り出す。
2. それぞれの座標についてabs(x)とabs(y)でxorを取ったあとにその結果すべてにand計算をして、必ず1本のアームが必要になるbitを割り出す。
3. それぞれの座標についてabs(x)とabs(y)でxorを取り、bitが立ったすべての地点についてもし足りないのであれば2^(bit-1)のアームを2本加える。

こうして得られたアームの本数が40本を上回っていれば作ることはできず、そうでなければ構成できる。

構成法もまた問題となる。構成法については、逆転の発想で考える。まず前準備というか前提として、上記の方法でアームを求めた場合、アームは長さ昇順で並び替えられる。このことをうまく活かす。

長さと動かす方向でpairを作り、それぞれの座標について必要な操作をすべてpairに記録する。xorで立っているケースの場合はまず残アーム数を確認し、現在のbitでの残アーム数が0であればその前のbitから2つ持ってくる（アーム数を求める手順の逆操作）。

使用したアームの数は長さごとに常に把握しておき余ったアームについては部分点解と同じように帳尻を合わせる。

理屈の上では間違っていなさそうなのだが、実装がややこしく自力では通せなかった。