# ARC098
Atcoder Regular Contest098の自分の解答

問題名見てｱｯ無理ってなって案の定ダメだった

# C
リーダーをある人に決めたとき、「リーダーより西で東を向いている人」「リーダーより東で西を向いている人」の和を最大化するとよい。これは西を向いている人と東を向いている人それぞれの累積和によって計算することでO(N)となる。

実際の答えは最大化された和+1（リーダーの分）をnから引いたものである。

あるいは最初から最小値を求めにいっても良い。その場合は逆の和を最小化することになる。この場合はリーダーの分を補正する必要はない。

# D
O(N^2)解からどうしても減らせなかった。

制約上明らかな累積和である。特にxorについて、ある数に別の数を2回xorするともとに戻ることから、xorについても同様の累積排他的論理和が実現できることが分かる。

以上の議論より、i番目からj番目までの累積和sum[j+1]-sum[i]とi番目からj番目までの累積排他的論理和(xor[j+1])xor(xor[i])が等しくなるi,j(i<=j)の数が答えであることが分かる。ただし、これだけではO(N^2)なのでまだ足りない。

iとjが2以上離れているときについて考える。このとき累積和と累積排他的論理和が等しくなるためには必ず区間内で連続する部分の和とxorが等しくなっていることが分かる。なぜならば、xorのビットを1回立ててからもとに戻すまでにsumは少なくとも立ったbit\*2だけ増加するためである。したがってiとjについては、隣接する部分さえ見れば良いことが分かる。

ある区間内の連続した部分のsumとxorがすべて等しいとき、区間内において任意にi<=jを満たす範囲でi,jを選べる。その選び方は1+2+...+(区間の要素数-1)+(区間の要素数)となる。

これでO(N)で求められるはずだが、実装がうまくいかなかった。おそらく連続した部分の判定法があいまいであったことが原因であると思われる。

### 追記（解説見た）
lを固定したとき条件を満たす最大のrは広義単調増加なので尺取り法にによってO(N)に減らせる。この方法の場合累積和を使う必要はないだろう。

結局最初に使っていた累積和を使って解いた。

# E
一見すると簡単そうだが、なかなか手ごわい問題のように見えた。

最小値とq番目に小さい値の差が答えになりそうだと思って提出したが、WA。その後、i番目とi+q番目に小さいものの値の差が最も小さくなるものが答えだと考え直したが、これはサンプルが通らなかった。おそらくi番目が最も小さくなるような部分列の取り出し方ができなかったためだと思われる。

nの制約が小さいためO(N^2)程度になりそうではある。したがってi番目が最も小さくなるような部分列の取り出し方をすべて試しても間に合いそうなのだが、これは実装を見送った。厳しそうだし。。。

### 追記（解説見た）
方針はおおむね間違っていない模様。ある値を最小値としたいとき、その値より小さい値で配列を分割していき、その中で取り出しを行うというのはとてもやりやすくなりそうな発想だった。

小さい値への保存、値の取り出しはdequeで行った。dequeつよい

そこから要素数がq未満になるまで最小のものを取り出す操作を行う。取り出したものはvectorに保存する。これである値を最小値としたとき取り出せる数字の集合が得られるのであとはソートしてq番目のものと1番目のものとの差を求める。これの最小値が答えである。