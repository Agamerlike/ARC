# ARC097
Atcoder Regular Contest097の自分の解答

Cでバグらせまくった結果微妙過ぎる2完に

# C
部分文字列を連続でなくてもよいと誤読した結果大幅にロス。その後vectorに追加する処理でstring型の扱いを誤りこれまた大幅にロス。素直にsubstr使えばよかった。

たとえば"baaaaab"みたいな文字列を考えてみると、5番目までの部分文字列はどうやらたかだか5文字に収まりそうだということが分かる。|s| <= 5000から5番目までの連続な部分文字列をすべて列挙した場合およそ25000通り存在する。これはソートしても十分間に合う数である。また同じ部分文字列は省くので、その点に注意する（こっちはO(N)）。ソートする部分でO(NlogN)となる。

# D
連続してスワップできる部分は任意の順番に並べ替えることができるので、連続してスワップできる部分、すなわち連結である集合に含まれるi,jの中で、p[i]=jを満たせるものはいくつありますか？　という問題に言い換えられる。

連結かどうかの判定はdfsとvectorによって行えるが、jがどのiと対応付けられるかの部分は愚直に行うとO(N^2)となり間に合わない。そこで、p[i]もjもそれぞれの中では同じものはひとつしかない（あるiに対してp[i]=jが成り立つjはひとつしか存在しない）ことを利用して考えられるp[i]をすべて連結成分のvectorの中に放り込み、ソートして同じものの数を数え上げるという方針をとったところうまくいった。

# E
2つの数列に対してバブルソートを行う問題だと思うのだが、コストの評価をうまく更新する方法が思いつかず解くのを断念。

同じ色のボール同士を交換したとき、その間にあるもう一方のボールの順番は変わらない。したがって、白を並べる→黒を並べるかその逆が最小値を実現する手法であることが想像できる。

それぞれの色のボールに書いてある数字の並びと、それぞれの色のボールを交換するには何回の操作が必要かをあらかじめ調べておく。このとき、バブルソートの要領でi番目とi-1番目のものを交換すると、コストはi-1番目とi番目のものが1になり、減った分はi-2番目とi-1番目のコストに足されることが分かる。これで一方の色の並べ替えはできた。

ここからもう一方のボールの交換コストを効率よく評価する方法が思いつかなかった。